// Implements functionality required to generate a new Certificate Request
// Uses Web Crypto API for ECDSA key generation, mimicking the CLI's behavior
// Generated by Cursor 1.1.6

import { CertificateSigningRequest } from '@flightctl/types';

/**
 * Convert ArrayBuffer to base64 string
 */
function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

/**
 * Generate ECDSA P-256 key pair using Web Crypto API
 */
async function generateECDSAKeyPair(): Promise<CryptoKeyPair> {
  try {
    const keyPair = await window.crypto.subtle.generateKey(
      {
        name: 'ECDSA',
        namedCurve: 'P-256',
      },
      true, // extractable
      ['sign', 'verify'],
    );

    return keyPair;
  } catch (error) {
    throw new Error(`Failed to generate ECDSA key pair: ${error}`);
  }
}

/**
 * Export key to PEM format
 */
export async function exportKeyToPem(key: CryptoKey): Promise<string> {
  try {
    const format = key.type === 'private' ? 'pkcs8' : 'spki';
    const exported = await window.crypto.subtle.exportKey(format, key);
    const base64 = arrayBufferToBase64(exported);
    const label = key.type === 'private' ? 'PRIVATE KEY' : 'PUBLIC KEY';

    // Format with 64-character lines
    const formatted = base64.match(/.{1,64}/g)?.join('\n') || base64;
    return `-----BEGIN ${label}-----\n${formatted}\n-----END ${label}-----`;
  } catch (error) {
    throw new Error(`Failed to export ${key.type} key: ${error}`);
  }
}

// DER encoding constants
const DER_SHORT_FORM_LIMIT = 128;
const DER_MEDIUM_FORM_LIMIT = 256;
const DER_LONG_FORM_PREFIX = 0x81;
const DER_EXTRA_LONG_FORM_PREFIX = 0x82;

/**
 * Encode length in DER format
 */
function encodeDERLength(length: number): Uint8Array {
  if (length < DER_SHORT_FORM_LIMIT) {
    // Short form: length fits in 7 bits
    return new Uint8Array([length]);
  } else if (length < DER_MEDIUM_FORM_LIMIT) {
    // Long form: 1 byte for length
    return new Uint8Array([DER_LONG_FORM_PREFIX, length]);
  } else {
    // Long form: 2 bytes for length
    return new Uint8Array([DER_EXTRA_LONG_FORM_PREFIX, (length >> 8) & 0xff, length & 0xff]);
  }
}

// ECDSA P-256 signature constants
const P256_R_BYTE_LENGTH = 32;
const P256_S_BYTE_LENGTH = 32;
const P256_SIGNATURE_BYTE_LENGTH = P256_R_BYTE_LENGTH + P256_S_BYTE_LENGTH;

// DER tag constants
const DER_INTEGER_TAG = 0x02;
const DER_SEQUENCE_TAG = 0x30;
const DER_POSITIVE_INTEGER_PREFIX = 0x00;
const DER_HIGH_BIT_MASK = 0x80;

/**
 * Convert Web Crypto API ECDSA signature to DER format expected by Go x509
 * Web Crypto returns raw r,s bytes (32 bytes each for P-256)
 * Go expects DER-encoded ASN.1 SEQUENCE { INTEGER r, INTEGER s }
 */
function convertECDSASignatureToDER(signature: Uint8Array): Uint8Array {
  // For P-256, signature is 64 bytes: 32 bytes r + 32 bytes s
  if (signature.length !== P256_SIGNATURE_BYTE_LENGTH) {
    throw new Error(`Invalid ECDSA signature length: ${signature.length}, expected ${P256_SIGNATURE_BYTE_LENGTH}`);
  }

  const r = signature.slice(0, P256_R_BYTE_LENGTH);
  const s = signature.slice(P256_R_BYTE_LENGTH, P256_SIGNATURE_BYTE_LENGTH);

  // Create DER-encoded INTEGERs for r and s
  const rDER = createDERInteger(r);
  const sDER = createDERInteger(s);

  // Create DER-encoded SEQUENCE containing r and s
  const content = new Uint8Array([...rDER, ...sDER]);
  const length = encodeDERLength(content.length);

  return new Uint8Array([DER_SEQUENCE_TAG, ...length, ...content]);
}

/**
 * Create DER-encoded INTEGER from unsigned byte array
 */
function createDERInteger(bytes: Uint8Array): Uint8Array {
  // Remove leading zeros
  let start = 0;
  while (start < bytes.length && bytes[start] === 0) {
    start++;
  }

  // If all zeros, keep one zero
  if (start === bytes.length) {
    start = bytes.length - 1;
  }

  const trimmedBytes = bytes.slice(start);

  // If the high bit is set, prepend 0x00 to make it positive
  const needsPadding = trimmedBytes[0] >= DER_HIGH_BIT_MASK;
  const finalBytes = needsPadding ? new Uint8Array([DER_POSITIVE_INTEGER_PREFIX, ...trimmedBytes]) : trimmedBytes;

  const length = encodeDERLength(finalBytes.length);

  return new Uint8Array([DER_INTEGER_TAG, ...length, ...finalBytes]);
}

// ASN.1 tag constants
const ASN1_SEQUENCE_TAG = 0x30;
const ASN1_BIT_STRING_TAG = 0x03;
const ASN1_CONTEXT_SPECIFIC_TAG = 0xa0;
const ASN1_UTF8_STRING_TAG = 0x0c;
const ASN1_SET_TAG = 0x31;
const ASN1_OID_TAG = 0x06;

// CSR structure constants
const CSR_VERSION_BYTES = [0x02, 0x01, 0x00]; // INTEGER 0
const CSR_EMPTY_ATTRIBUTES = [ASN1_CONTEXT_SPECIFIC_TAG, 0x00]; // Empty attributes
const COMMON_NAME_OID = [ASN1_OID_TAG, 0x03, 0x55, 0x04, 0x03]; // Common Name OID

/**
 * Create a proper PKCS#10 Certificate Signing Request
 * This creates a basic but valid DER-encoded CSR in PEM format
 */
export async function createCsrPem(commonName: string, keyPair: CryptoKeyPair): Promise<string> {
  try {
    // Export the public key in SPKI format
    const publicKeyDER = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
    const publicKeyBytes = new Uint8Array(publicKeyDER);

    // Create a basic ASN.1 structure for PKCS#10 CSR
    // This is a simplified but valid PKCS#10 structure

    // Subject: CN=commonName
    const commonNameBytes = new TextEncoder().encode(commonName);
    const subjectDN = createSubjectDN(commonNameBytes);

    // CSR Info structure: version + subject + public key + attributes
    const version = new Uint8Array(CSR_VERSION_BYTES);
    const attributes = new Uint8Array(CSR_EMPTY_ATTRIBUTES);

    // Create CSR Info content
    const csrInfoContent = new Uint8Array([...version, ...subjectDN, ...publicKeyBytes, ...attributes]);

    // Create CSR Info with proper length encoding
    const csrInfoLength = encodeDERLength(csrInfoContent.length);
    const csrInfo = new Uint8Array([ASN1_SEQUENCE_TAG, ...csrInfoLength, ...csrInfoContent]);

    // Sign the CSR info with the private key
    const rawSignature = await window.crypto.subtle.sign(
      {
        name: 'ECDSA',
        hash: { name: 'SHA-256' },
      },
      keyPair.privateKey,
      csrInfo,
    );

    // Convert Web Crypto raw signature to DER format for Go compatibility
    const signatureBytes = convertECDSASignatureToDER(new Uint8Array(rawSignature));

    // We must create the following fields to define a PKCS#10 CertificationRequest ASN.1 object (RFC 2986)
    // CertificationRequest ::= SEQUENCE {
    //   certificationRequestInfo CertificationRequestInfo,
    //   signatureAlgorithm       AlgorithmIdentifier,
    //   signature                BIT STRING
    // }

    // Signature algorithm: ECDSA with SHA-256 OID
    const signatureAlgorithm = new Uint8Array([
      ASN1_SEQUENCE_TAG,
      0x0a, // SEQUENCE length
      ASN1_OID_TAG,
      0x08, // OID length
      0x2a,
      0x86,
      0x48,
      0xce,
      0x3d,
      0x04,
      0x03,
      0x02, // ECDSA with SHA-256 OID
    ]);

    // Signature as BIT STRING with proper length encoding
    const signatureBitStringLength = encodeDERLength(signatureBytes.length + 1);
    const signatureBitString = new Uint8Array([
      ASN1_BIT_STRING_TAG,
      ...signatureBitStringLength,
      0x00, // No unused bits
      ...signatureBytes,
    ]);

    // Complete CSR content
    const completeCsrContent = new Uint8Array([...csrInfo, ...signatureAlgorithm, ...signatureBitString]);

    // Complete CSR with proper length encoding
    const completeCsrLength = encodeDERLength(completeCsrContent.length);
    const completeCsr = new Uint8Array([ASN1_SEQUENCE_TAG, ...completeCsrLength, ...completeCsrContent]);

    // Convert to base64 and format as PEM
    const base64CSR = arrayBufferToBase64(completeCsr.buffer);
    const formatted = base64CSR.match(/.{1,64}/g)?.join('\n') || base64CSR;

    return `-----BEGIN CERTIFICATE REQUEST-----\n${formatted}\n-----END CERTIFICATE REQUEST-----`;
  } catch (error) {
    throw new Error(`Failed to create CSR: ${error}`);
  }
}

/**
 * Create ASN.1 Subject Distinguished Name
 */
function createSubjectDN(commonNameBytes: Uint8Array): Uint8Array {
  // Subject: CN=commonName
  // This creates: SEQUENCE { SET { SEQUENCE { OID, UTF8String } } }

  const cnOID = new Uint8Array(COMMON_NAME_OID);

  // Create UTF8String with proper length encoding
  const cnValueLength = encodeDERLength(commonNameBytes.length);
  const cnValue = new Uint8Array([ASN1_UTF8_STRING_TAG, ...cnValueLength, ...commonNameBytes]);

  // Create SEQUENCE (OID + UTF8String) with proper length encoding
  const cnAttributeContent = new Uint8Array([...cnOID, ...cnValue]);
  const cnAttributeLength = encodeDERLength(cnAttributeContent.length);
  const cnAttribute = new Uint8Array([ASN1_SEQUENCE_TAG, ...cnAttributeLength, ...cnAttributeContent]);

  // Create SET containing the attribute with proper length encoding
  const cnSetLength = encodeDERLength(cnAttribute.length);
  const cnSet = new Uint8Array([ASN1_SET_TAG, ...cnSetLength, ...cnAttribute]);

  // Create outer SEQUENCE with proper length encoding
  const subjectLength = encodeDERLength(cnSet.length);
  const subject = new Uint8Array([ASN1_SEQUENCE_TAG, ...subjectLength, ...cnSet]);

  return subject;
}

/**
 * Generates the necessary private and public key pair and the CSR PEM that are required to create a CSR via the API
 */
export async function generateCsrKeys(csrName: string): Promise<{
  privateKeyPem: string;
  publicKeyPem: string;
  csrPem: string;
}> {
  try {
    // Generate ECDSA P-256 key pair
    const keyPair = await generateECDSAKeyPair();

    // Export keys to PEM format
    const privateKeyPem = await exportKeyToPem(keyPair.privateKey);
    const publicKeyPem = await exportKeyToPem(keyPair.publicKey);

    // Create CSR
    const csrPem = await createCsrPem(csrName, keyPair);

    return {
      privateKeyPem,
      publicKeyPem,
      csrPem,
    };
  } catch (error) {
    throw new Error(`Failed to create certificate request: ${error}`);
  }
}

export function getApiCsrRequest(csrName: string, csrPem: string, expirationDays: number): CertificateSigningRequest {
  const SECONDS_PER_DAY = 24 * 60 * 60;
  const expirationSeconds = expirationDays * SECONDS_PER_DAY;

  const csrResource: CertificateSigningRequest = {
    apiVersion: 'v1alpha1',
    kind: 'CertificateSigningRequest',
    metadata: {
      name: csrName,
    },
    spec: {
      expirationSeconds,
      request: btoa(csrPem), // Base64 encode PEM content (Go's JSON marshaler does this automatically for []byte fields)
      signerName: 'enrollment',
      usages: ['clientAuth', 'CA:false'],
    },
  };

  return csrResource;
}

/**
 * Type for the POST function used to submit CSR requests
 */
type PostFunction = (path: string, body: CertificateSigningRequest) => Promise<CertificateSigningRequest>;

/**
 * Complete workflow to replicate CLI certificate request command
 */
export async function createNewCertificateSigningRequest(
  post: PostFunction,
  csrName: string,
  expirationDays: number,
): Promise<{
  privateKeyPem: string;
  publicKeyPem: string;
  csrPem: string;
  fullCsr: CertificateSigningRequest;
}> {
  try {
    // Create certificate request keys
    const { privateKeyPem, publicKeyPem, csrPem } = await generateCsrKeys(csrName);

    // Submit to API
    const fullCsr = await post('certificatesigningrequests', getApiCsrRequest(csrName, csrPem, expirationDays));

    return {
      privateKeyPem,
      publicKeyPem,
      csrPem,
      fullCsr,
    };
  } catch (error) {
    throw new Error(`Certificate request workflow failed: ${error}`);
  }
}

/**
 * Check browser support
 */
export function isBrowserCryptoSupported(): boolean {
  return !!(
    window.crypto &&
    window.crypto.subtle &&
    typeof window.crypto.subtle.generateKey === 'function' &&
    typeof window.crypto.subtle.exportKey === 'function'
  );
}
